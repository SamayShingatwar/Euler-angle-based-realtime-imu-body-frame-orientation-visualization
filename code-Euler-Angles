from vpython import*
from time import*
import numpy as np
import math
import serial
ad = serial.Serial('com5', 115200)
sleep(1)

scene.range = 5
toRad = 2*np.pi/360
toDeg = 1/toRad
scene.forward = vector(-1,-1,-1)

scene.width = 600
scene.height = 600

xarrow = arrow(length = 2, shaftwidth = .1, color = color.red, axis = vector(1,0,0))
yarrow = arrow(length = 2, shaftwidth = .1, color = color.blue, axis = vector(0,1,0))
zarrow = arrow(length = 2, shaftwidth = .1, color = color.green, axis = vector(0,0,1))

frontArrow = arrow(length = 4, shaftwidth = .1, color = color.purple, axis = vector(1,0,0))
upArrow = arrow(length = 1, shaftwidth = .1, color = color.magenta, axis = vector(0,1,0))
sideArrow = arrow(length = 1, shaftwidth = .1, color = color.orange, axis = vector(0,0,1))

bBoard = box(length = 6, width = 2, height = .2, opacity = .8, pos = vector(0,0,0))
bn = box(length = 1, width = .75, height = .1, pos = vector(-.5, .1+.05, 0), color = color.blue)
nano = box(length = 1.75, width = .6, height = .1, pos = vector(-2, .1+.05, 0), color = color.green)

myObj = compound([bBoard, nano, bn])

while True:

    if ad.in_waiting == 0:     # check if serial data exists,if no new data is available, skip this frame. (continue is for the while loop, so if data = 0 then rest of the code below is skipped)
        continue
    while ad.in_waiting > 1: #flush old data packets: arduino might send data faster than python can read, so this discards all but the new data packets so there is no lag..python visualize "history" â†’ multi-second lag
        ad.readline()   # read + ignore (while loop: can run multiple iterations until there is no backlog in a single loop)

    dataPacket = ad.readline().decode('utf-8', errors='ignore').strip()
    splitPacket = dataPacket.split(",")

    if len(splitPacket) != 3: #skip packet if doesnt have 3 pieces
        continue

    roll  = float(splitPacket[1]) * toRad
    pitch = float(splitPacket[0]) * toRad
    yaw   = float(splitPacket[2]) * toRad
    yaw   = yaw % (2*np.pi)

    rate(60)

    k = vector(math.cos(yaw)*math.cos(pitch), math.sin(pitch), math.sin(yaw)*math.cos(pitch))

    world_up = vector(0,1,0)
    s = norm(cross(k, world_up))
    v = norm(cross(s, k))
    k = norm(k)
    vrot = v*cos(roll) + cross(k,v)*sin(roll)
    vrot = norm(vrot)

    frontArrow.axis = k
    sideArrow.axis  = cross(k, vrot)
    upArrow.axis    = vrot

    myObj.axis = k
    myObj.up   = vrot
